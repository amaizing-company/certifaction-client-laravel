{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This laravel package acts as client and allows your application to communicate with certifactions signature services.  It contains preconfigured jobs, events and database models, they easily could integrate into your application.  It provides also the ability to work directly with the api request and response classes, in case you want to build up your own logic.</p> <p>The package is dependent on Certifaction's services. An account and an API key from Certifaction are required to  communicate with Certifaction's service. Further information can be found on the Certifaction website.  https://certifaction.com</p>"},{"location":"basics/","title":"Basics","text":"<p>The package is based on a client api, which was developed for laravel. This allows you to use the package in different  ways:</p> <ol> <li>with the predefined workflow via the database models, jobs, events and commands.</li> <li>with your own workflow directly via the API classes.</li> </ol> <p>The documentation mainly deals with the first use case with the pre-defined workflows, as this can also explain the use  of the API classes.</p>"},{"location":"basics/#jobs-and-events","title":"Jobs and Events","text":"<p>The package relies on jobs to execute various actions. Most jobs trigger several events. Based on these events, you  can customize the workflow to the needs of your application. You can find an explanation of the existing events  in Events</p>"},{"location":"basics/#model-based-configuration","title":"Model-based configuration","text":"<p>Since the package supports multiple user or document models. The configuration for the model-dependent methods can  be carried out directly in the models. You can find out more about the configuration and extension options  under Models.</p>"},{"location":"broadcasting/","title":"Broadcasting","text":"<p>Page under construction.</p>"},{"location":"events/","title":"Events","text":"<p>Page under consturction.</p>"},{"location":"installation_setup/","title":"Installation and setup","text":""},{"location":"installation_setup/#basic-installation","title":"Basic installation","text":"<p>You can install the package via composer:</p> <pre><code>composer require amaizing-company/certifaction-client-laravel\n</code></pre> <p>You can publish and run the migrations with:</p> <pre><code>php artisan vendor:publish --tag=\"certifaction-client-laravel-migrations\"\nphp artisan migrate\n</code></pre> <p>You should publish the config file with:</p> <pre><code>php artisan vendor:publish --tag=\"certifaction-client-laravel-config\"\n</code></pre> <p>This is the contents of the published config file:</p> <pre><code>return [\n    /*\n     * API\n     *\n     * Set environment endpoints and credentials to initiate communication with certifaction api servers.\n     * To avoid security risks, this configuration should only be defined via the environment variables.\n     */\n    'api' =&gt; [\n        'environments' =&gt; [\n            CertifactionEnvironment::LOCAL-&gt;value =&gt; env('CERTIFACTION_LOCAL_URI'),\n            CertifactionEnvironment::ADMIN-&gt;value =&gt; env('CERTIFACTION_ADMIN_URI'),\n        ],\n        'auth' =&gt; [\n            'key' =&gt; env('CERTIFACTION_CLIENT_API_KEY'),\n        ],\n    ],\n\n    /*\n     * DATABASE\n     *\n     * Defines the behavior of database migrations.\n     */\n    'database' =&gt; [\n        'table_prefix' =&gt; 'certifaction_',\n    ],\n\n    /*\n     * The default jurisdiction that used to create requests.\n     */\n    'jurisdiction' =&gt; Jurisdiction::EIDAS,\n\n    /*\n     * The default role ID for new users.\n     */\n    'role_id' =&gt; '',\n\n    /*\n     * Determines if certifaction should store a digital twin of documents in there cloud. This can be overwritten from config\n     * of a signable document and is used when no other config provided.\n     */\n    'digital_twin' =&gt; false,\n\n    /*\n     * Determines if documents are in general in pdf-a format. This can be overwritten from config\n     * of a signable document and is used when no other config provided.\n     */\n    'pdf_a' =&gt; false,\n\n    /*\n     * Determines if certifaction should notify the signer about a new request. This can be overwritten from config\n     * of a signable document and is used when no other config provided.\n     */\n    'notify_signer' =&gt; false,\n\n    /*\n     * The default webhook url that is called when a signature request finished. This can be overwritten from config\n     * of a signable document and is used when no other config provided.\n     */\n    'webhook_url' =&gt; '',\n\n    /*\n     * STORAGE\n     *\n     * The storage config allows to define where signed and downloaded documents should be stored. This config can be\n     * overwritten inside the model configuration of a signable document model that uses the certifaction documents\n     * concern.\n     */\n    'storage_disk' =&gt; 'local',\n    'storage_directory' =&gt; 'certifaction/documents',\n\n    /*\n     * BROADCASTING\n     *\n     * If broadcasting is expected for events set this option true.\n     */\n    'broadcasting' =&gt; false,\n\n    /*\n     * Enable default package routes.\n     */\n    'default_routes' =&gt; true,\n];\n</code></pre>"},{"location":"installation_setup/#certifaction-local-api-server","title":"Certifaction Local API Server","text":"<p>To setup Certifaction's local api server you need to create a docker container that servs the application. </p> <p>Pull the image with:</p> <pre><code>docker pull certifaction/server:latest\n</code></pre> <p>Start the local api with:</p> <pre><code>docker run -p 8082:8002 certifaction/server:latest \n</code></pre> <p>Certifaction API will be exposed on the the default http://localhost:8082 HTTP server.</p>"},{"location":"installation_setup/#api-key","title":"API Key","text":"<p>Receive an api key by following the instructions from  Certifactions installation guide. You will need it for the next step in configuration.</p>"},{"location":"installation_setup/#basic-configuration","title":"Basic Configuration","text":"<p>To make your application able to communicate with Certifaction's services you need to set some environment variables.</p> <p>Set the local api server uri. This should be the exposed uri from your local certifaction api server.</p> <pre><code>CERTIFACTION_LOCAL_URI=http://localhost:8082\n</code></pre> <p>Set the admin api server uri. You can find the correct address by visiting  Certifaction's admin api reference.</p> <pre><code>CERTIFACTION_ADMIN_URI=https://api.certifaction.io\n</code></pre> <p>Set the api key:</p> <pre><code>CERTIFACTION_CLIENT_API_KEY=[YOUR_API_KEY]\n</code></pre> <p>Now your application should be able to reach Certifaction's api services. To check your local server is reachable, you  can using the ping command:</p> <pre><code>php artisan certifaction:server:ping\n</code></pre> <p>If you want to have more detailed information about your local server you can use the server health command:</p> <pre><code>php artisan certifaction:server:health\n</code></pre>"},{"location":"installation_setup/#basic-model-configuration","title":"Basic Model Configuration","text":"<p>The database models from this package needs two models they defined from application. A user model and a  document file model. This models needs some preparation before they can used with this package.</p>"},{"location":"installation_setup/#the-user-model","title":"The User Model","text":"<p>The signer model typically are your user models. Each model that should be able to interact with this package needs  following preparation: </p> <pre><code>use AmaizingCompany\\CertifactionClient\\Contracts\\CertifactionUser;\nuse AmaizingCompany\\CertifactionClient\\Concerns\\HasCertifactionAccount;\n\nclass User extends Model implements CertifactionUser\n{\n    use HasCertifactionAccount;\n\n    // ...\n}\n</code></pre> <p>So that the package methods know how to retrieve the required parameters, these must be defined separately via  methods within the model.</p> <pre><code>class User extends Model implements CertifactionUser\n{\n    use HasCertifactionAccount;\n\n    public function getEmail(): string \n    {\n        // Return the email address for the user.\n    }\n\n    public function getBirthdate(): string \n    {\n        // Return the birthdate for the user. Use format yyyy-mm-dd.\n    }\n\n    public function getFirstName(): string \n    {\n        // Return the first name for the user\n    }\n\n    public function getLastName(): string \n    {\n        // Return the last name for the user\n    }\n\n    public function getMobilePhone(): string\n    {\n        // Return the mobile phone number of the user\n    }\n}\n</code></pre>"},{"location":"installation_setup/#the-document-file-model","title":"The Document File Model","text":"<p>This models typically handle where your files are stored and how they named. Each model that should be able to interact with this package needs following preparation:</p> <pre><code>use AmaizingCompany\\CertifactionClient\\Concerns\\HasCertifactionDocuments;\nuse AmaizingCompany\\CertifactionClient\\Contracts\\Signable;\n\nclass Document extends Model implements Signable\n{\n    use HasCertifactionDocuments;\n\n    // ...\n}\n</code></pre> <p>So that the package methods know how to retrieve the required parameters, these must be defined separately via methods within the model. </p> <pre><code>use AmaizingCompany\\CertifactionClient\\Contracts\\CertifactionUser;\n\nclass Document extends Model implements Signable\n{\n    use HasCertifactionDocuments;\n\n    public function getDocumentName(): string\n    {\n        // Return the name for the document.\n    }\n\n    public function getFileContents(): string\n    {\n        // Return the file contnents of the document as raw string\n    }\n\n    public function getSigner(): CertifactionUser\n    {\n        // Return a user model that acts as signer for the document type\n    }\n}\n</code></pre>"},{"location":"installation_setup/#scheduling","title":"Scheduling","text":"<p>When you are creating signature requests, normally you want to download the signed documents after the request was  finished on Certifaction's server site. The package creates file transactions for that. To process this file  transactions it could be useful to schedule the job that done this.</p> <p>Set the following schedulers to make sure all background tasks will be executed.</p> routes/console.php<pre><code>// ...\nuse Illuminate\\Support\\Facades\\Schedule;\n\nSchedule::job(\\AmaizingCompany\\CertifactionClient\\Jobs\\ProcessOpenFileTransactions::class)-&gt;everyMinute();\nSchedule::job(\\AmaizingCompany\\CertifactionClient\\Jobs\\ProcessAccountSync::class)-&gt;everyFiveMinutes();\nSchedule::job(\\AmaizingCompany\\CertifactionClient\\Jobs\\ProcessIntentedIdentityTransactions::class)-&gt;everyFiveMinutes();\nSchedule::job(\\AmaizingCompany\\CertifactionClient\\Jobs\\ProcessPendingIdentityTransactions::class)-&gt;everyFiveMinutes();\nSchedule::job(\\AmaizingCompany\\CertifactionClient\\Jobs\\ProcessPendingSignatureTransactions::class)-&gt;everyFiveMinutes();\n// ...\n</code></pre>"},{"location":"installation_setup/#broadcasting","title":"Broadcasting","text":"<p>All events of this package supporting broadcasting. Broadcasting is disabled by default. It can be enabled by setting the config for boradcasting to true.</p> config/certifaction-client-laravel.php<pre><code>// ...\n\nbroadcasting =&gt; true,\n\n// ...\n</code></pre>"},{"location":"models/","title":"Models","text":""},{"location":"models/#application-models","title":"Application Models","text":"<p>For the package to work properly, your application needs two types of models. A user model which holds the information  for the signatory and a document model which holds the basic information about the files.</p> <p>Your application can also define multiple users and multiple document models. This does not change the workflow.</p> <p>If the use case is not practical for your application, you can also take a look at the advanced usage documentation  to define your own workflows.</p>"},{"location":"models/#user-model","title":"User Model","text":""},{"location":"models/#setup","title":"Setup","text":"<p>To set up the user model implement the <code>CertifactionUser</code> contract and the <code>HasCertifactionAccount</code> trait.</p> <pre><code>use AmaizingCompany\\CertifactionClient\\Contracts\\CertifactionUser;\nuse AmaizingCompany\\CertifactionClient\\Concerns\\HasCertifactionAccount;\n\nclass User extends Model implements CertifactionUser\n{\n    use HasCertifactionAccount;\n\n    // ...\n}\n</code></pre>"},{"location":"models/#configuration-methods","title":"Configuration Methods","text":"<p>To help the package reading the values from your applications user model, its required to define some configuration  methods inside the model.</p>"},{"location":"models/#getbirthdate","title":"getBirthdate","text":"<p>Is required and should return the birthdate of the user.</p> <pre><code>public function getBirthdate(): string|\\Illuminate\\Support\\Carbon\n{\n    return 'yyyy-mm-dd';\n    // or\n    return \\Illuminate\\Support\\Carbon::make('2025-01-01');\n}\n</code></pre>"},{"location":"models/#getemail","title":"getEmail","text":"<p>Is required and should return a valid email address.</p> <pre><code>public function getEmail(): string\n{\n    return 'test@example.com';\n}\n</code></pre>"},{"location":"models/#getfirstname","title":"getFirstName","text":"<p>Is required and should return the single first name or multiple first names of the user.</p> <pre><code>public function getFirstName(): string\n{\n    return 'John';\n    // or\n    return \"John Edward\"\n}\n</code></pre>"},{"location":"models/#getlastname","title":"getLastName","text":"<p>Is required and should return the last name of the user.</p> <pre><code>public function getLastName(): string\n{\n    return 'Doe';\n}\n</code></pre>"},{"location":"models/#getmobilephone","title":"getMobilePhone","text":"<p>Is required and should return a valid mobile phone number of the user.</p> <pre><code>public function getMobilePhone(): string\n{\n    return '+4912345678910';\n}\n</code></pre>"},{"location":"models/#document-model","title":"Document Model","text":""},{"location":"models/#setup_1","title":"Setup","text":"<p>To set up the document model implement the <code>Signable</code> Contract and the <code>HasCertifactionDocuments</code> Concern.</p> <pre><code>use AmaizingCompany\\CertifactionClient\\Contracts\\Signable;\nuse AmaizingCompany\\CertifactionClient\\Concerns\\HasCertifactionDocuments;\n\nclass Document extends Model implements Signable \n{\n    use HasCertifactionDocuments;\n\n    // ...\n}\n</code></pre>"},{"location":"models/#configuration-methods_1","title":"Configuration Methods","text":"<p>To help the package reading some parameters and configurations from your applications documents model, you should define some configuration methods. Some of them are required. Configuration methods give you the flexibility to configure your  document types based on the document model.</p>"},{"location":"models/#getdocumentname","title":"getDocumentName","text":"<p>Is required and should return the name of the document. </p> <pre><code>public function getDocumentName(): string\n{\n    return 'my_document';\n}\n</code></pre>"},{"location":"models/#getencryptionkey","title":"getEncryptionKey","text":"<p>Is optional and should return the encryption key with that the document was encrypted if it uses an encryption. Make sure that the withPassword method returns true if you want use this option.</p> <pre><code>public function getEncryptionKey(): ?string\n{\n    return null;\n}\n</code></pre>"},{"location":"models/#getfilecontents","title":"getFileContents","text":"<p>Is required and should return the raw file contents of the document. </p> <pre><code>public function getFileContents(): string\n{\n    return \\Illuminate\\Support\\Facades\\Storage::get('PATH_TO_DOCUMENT');\n}\n</code></pre>"},{"location":"models/#getwebhookurl","title":"getWebhookUrl","text":"<p>Is required and should return the webhook url that is called when a signatory has finished a signature request. By default it returns the global configuration for webhook url. </p> <pre><code>use AmaizingCompany\\CertifactionClient\\Facades\\CertifactionClient;\n\npublic function getWebhookUrl(): string\n{\n    return CertifactionClient::getConfig('webhook_url');\n}\n</code></pre>"},{"location":"models/#hasadditionalpage","title":"hasAdditionalPage","text":"<p>Is required and should return if the signature should be placed at an additional page. By default, it returns false.</p> <pre><code>use AmaizingCompany\\CertifactionClient\\Facades\\CertifactionClient;\n\npublic function hasAdditionalPage(): bool\n{\n    return false;\n}\n</code></pre>"},{"location":"models/#hasdigitaltwin","title":"hasDigitalTwin","text":"<p>Is required and should return if the document should store as digital twin on certifaction's servers. This will place a qr code at the document that stores the url to call the digital twin. If this option is set true, the following  methods need to be set:</p> <ul> <li>qrCodePositionX</li> <li>qrCodePositionY</li> <li>qrCodeHeight</li> <li>qrCodePageNumber</li> </ul> <pre><code>use AmaizingCompany\\CertifactionClient\\Facades\\CertifactionClient;\n\npublic function hasDigitalTwin(): bool\n{\n    return CertifactionClient::getConfig('digital_twin');\n}\n</code></pre>"},{"location":"models/#ispdfa","title":"isPdfA","text":"<p>Is required and should return if the document is a document in PDF-A standard. By default it returns the global config for pdf a.</p> <pre><code>use AmaizingCompany\\CertifactionClient\\Facades\\CertifactionClient;\n\npublic function isPdfA(): bool\n{\n    return CertifactionClient::getConfig('pdf_a');\n}\n</code></pre>"},{"location":"models/#qrcodepositionx","title":"qrCodePositionX","text":"<p>Is required when hasDigitalTwin is set true and should return the x coordinate on where the qr code is placed.</p> <pre><code>public function qrCodePositionX(): int\n{\n    return 0;\n}\n</code></pre>"},{"location":"models/#qrcodepositiony","title":"qrCodePositionY","text":"<p>Is required when hasDigitalTwin is set true and should return the y coordinate on where the qr code is placed.</p> <pre><code>public function qrCodePositionY(): int\n{\n    return 0;\n}\n</code></pre>"},{"location":"models/#qrcodeheight","title":"qrCodeHeight","text":"<p>Is required when hasDigitalTwin is set true and should return the height in pixel of the qr code.</p> <pre><code>public function qrCodeHeight(): int\n{\n    return 50;\n}\n</code></pre>"},{"location":"models/#qrcodepagenumber","title":"qrCodePageNumber","text":"<p>Is required when hasDigitalTwin is set true and should return the page number on where the digital twin should  be placed.</p> <pre><code>public function qrCodePageNumber(): int\n{\n    return 1;\n}\n</code></pre>"},{"location":"models/#signaturepositionx","title":"signaturePositionX","text":"<p>Is required and should return the x coordinate on where the signature should be placed.</p> <pre><code>public function signaturePositionX(): int\n{\n    return 0;\n}\n</code></pre>"},{"location":"models/#signaturepositiony","title":"signaturePositionY","text":"<p>Is required and should return the y coordinate on where the signature should be placed.</p> <pre><code>public function signaturePositionY(): int\n{\n    return 0;\n}\n</code></pre>"},{"location":"models/#signatureheight","title":"signatureHeight","text":"<p>Is required and should return the height of the signature.</p> <pre><code>public function signatureHeight(): int\n{\n    return 50;\n}\n</code></pre>"},{"location":"models/#signaturepagenumber","title":"signaturePageNumber","text":"<p>Is required and should return the page number on where the signature should be placed at.</p> <pre><code>public function signaturePageNumber(): int\n{\n    return 1;\n}\n</code></pre>"},{"location":"models/#storagedisk","title":"storageDisk","text":"<p>Is optional and should return the storage disk on where signed documents will be stored on. If nothing is set, the  global config for storage_disk is used.</p> <pre><code>public function storageDisk(): ?string\n{\n    return null;\n}\n</code></pre>"},{"location":"models/#storagedirectory","title":"storageDirectory","text":"<p>Is optional and should return the storage directory on where signed documents will be stored on. If nothing is set, the global config for storage_directory is used.</p> <pre><code>public function storageDirectory(): ?string\n{\n    return null;\n}\n</code></pre>"},{"location":"models/#withpassword","title":"withPassword","text":"<p>Is required and should return if the document is encrypted with an encryption string. If this option is set true, the getEncryptionKey method should return the encryption key for the document.</p> <pre><code>public function withPassword(): bool\n{\n    return false;\n}\n</code></pre>"},{"location":"models/#package-models","title":"Package Models","text":"<p>Here is a list of all models of this package.</p> Model Description Account Holds certifaction account records Document Holds document records for certifaction documents FileTransaction Holds records for all file transactions IdentityTransaction Holds records for all identity transactions SignatureTransaction Holds records for all signature transactions"},{"location":"models/#extend-package-models","title":"Extend Package Models","text":"<p>All package models are fully extendable. The package use a service container binding to make it possible to overwrite  them from your applications site. </p> <p>Here we extend the Account model for example.</p> <pre><code>use AmaizingCompany\\CertifactionClient\\Contracts\\Account as AccountContract;\nuse AmaizingCompany\\CertifactionClient\\Models\\Account; \n\nclass MyDefaultAccountModel extends Account implements AccountContract\n{\n    // ...\n}\n</code></pre> <p>Inside your service provider just bind your default model to the contract.</p> <pre><code>use AmaizingCompany\\CertifactionClient\\Contracts\\Account;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    public function register() \n    {\n        // ...\n\n        $this-&gt;app-&gt;bind(Account::class, MyDefaultAccountModel::class);\n    }\n}\n</code></pre> <p>Now the package will use your default model instead of the package model for all defined operations. </p>"},{"location":"requirements/","title":"Requirements","text":"<p>This package requires PHP 8.4 or higher and Laravel 11 or higher. </p> <p>The package is dependent on Certifaction's services. An account and an API key from Certifaction are required to communicate with Certifaction's service. </p> <p>The package also needs the Certifaction local api client that should run inside a docker container.  More information could be found inside the  installation guide from Certifaction.</p>"},{"location":"signature_requests/","title":"Signature Requests","text":"<p>Signature requests are the core feature of this package. If documents are to be signed by a user, they must first be  prepared and can then be combined into a signature request. This procedure remains the same regardless of whether one  document or several documents are to be signed.</p>"},{"location":"signature_requests/#prepare-documents","title":"Prepare Documents","text":"<p>First, all documents that are to be signed must be prepared. To do this, the documents are sent to Certifaction.  Certifaction then sends back a URL under which the documents are made available for signing. These URLs can then be  used to create a signature request.</p> <p>To prepare an document, a request can be sent directly via the signable document model of your application. Before you  start prepare an document you have to create a new signature transaction for the related user to assign the prepared  documents to it. </p> <p><pre><code>use AmaizingCompany\\CertifactionClient\\Contracts\\CertifactionUser;\nuse AmaizingCompany\\CertifactionClient\\Contracts\\Signable;\nuse AmaizingCompany\\CertifactionClient\\Enums\\DocumentPrepareScope;\nuse AmaizingCompany\\CertifactionClient\\Enums\\SignatureType;\n\n/**\n * @var CertifactionUser $user \n */\n$transaction = $user-&gt;createSignatureTransaction(SignatureType::SES);\n\n/**\n * @var Signable $document\n */\n$document-&gt;requestPreparation(DocumentPrepareScope::SIGN, $transaction);\n</code></pre> When the request has been processed, either the <code>DocumentPrepared</code> or the <code>DocumentPreparationFailed</code> event is  triggered, depending on the status of the request.</p>"},{"location":"signature_requests/#start-a-signature-request","title":"Start a Signature Request","text":"<p>To start a new signature request, you need an already created signature transaction with prepared documents attached.  Then you can trigger a job by calling the related method from the certifaction client facade.</p> <pre><code>use AmaizingCompany\\CertifactionClient\\Facades\\CertifactionClient;\n\nCertifactionClient::requestSignature($transaction);\n</code></pre> <p>After the job has finished, it will trigger the <code>SignatureRequestStarted</code> or the <code>SignatureRequestFailed</code> event. </p> <p>A successful signature request will store the url to finish the request by signing the documents inside the signature transaction record. You can access it like this:</p> <pre><code>use AmaizingCompany\\CertifactionClient\\Models\\SignatureTransaction;\n\n/**\n * @var SignatureTransaction $transaction\n */\n$transaction-&gt;request_url;\n</code></pre>"},{"location":"signature_requests/#finish-a-signature-transaction","title":"Finish a Signature Transaction","text":"<p>To finish a signature transaction, the signatory should sign all files under the given request url. If this happened,  certifaction will call a webhook url. This is the url you have set inside the global package configuration or inside  your document model. The package already provides an preconfigured webhook workflow, which will call the  <code>ProcessWebhook</code> job. This job handle all documents of the signature transaction by checking their status against the  status of the signature request, update the database records and download all signed documents inside the  configured storage.</p> <p>Depending on the status of the job, it will trigger the <code>SignatureRequestFinished</code> or the <code>SignatureRequestFailed</code>  event. </p> <p>To ensure a signature transaction will get finished, its recommended to schedule the  <code>ProcessPendingSignatureTransactions</code> job, which will trigger the <code>ProcessWebhook</code> job for any pending signature  transaction. If all documents inside a signature request are unsigned the transaction stays on status pending.</p>"},{"location":"users_accounts/","title":"Users &amp; Accounts","text":"<p>To interact with this package, the user models of your application needs to be setup correctly. Please have a look into  Installation &amp; Setup to prepare your user models.</p> <p>Accounts are necessary to create signature requests from this package. Before you starting have a look into other types of usage, make sure you have read this topic.</p>"},{"location":"users_accounts/#invite-a-user-to-certifaction","title":"Invite a user to Certifaction","text":"<p>Before getting start to invite a user to certifaction make sure you know the existing role ID's and have configured a  default role ID inside the package configuration. To get an overview to all existing role ID's of your ceriifaction  instance, you can call the following command:</p> <pre><code>php artisan certifaction:roles:list\n</code></pre> <p>From the output you can choose a role ID and copy it to the configuration key. We recommend don't choosing the admin  role ID to avoid potential security issues.</p> config/certifaction-client-laravel.php<pre><code>return [\n    // ...\n\n    role_id =&gt; YOUR_DEFAULT_ROLE_ID,\n\n    // ...\n]\n</code></pre> <p>Now the package is able to get a default role id for user invitations.</p> <p>To invite a existing user to certifaction you can call a predefined job like this: </p> <pre><code>use App\\Models\\User;\n\n/**\n * @var User $user\n */\n$user-&gt;inviteToCertifaction();\n</code></pre> <p>If you want to specify a different role ID for an invitation you can do this by setting the second parameter with the  role ID.</p> <pre><code>$user-&gt;inviteToCertifaction('ROLE_ID');\n</code></pre> <p>You also can call the job directly; <pre><code>use AmaizingCompany\\CertifactionClient\\Jobs\\ProcessUserInvitation;\n\nProcessUserInvitation::dispatch($user, 'ROLE_ID');\n</code></pre></p> <p>If the job was successful the job will trigger the <code>UserInvitedToCertifaction</code> event and a new account relationship will  create for the given user. You can access the account record by calling:</p> <pre><code>$user-&gt;certifactionAccount()-&gt;first();\n</code></pre> <p>Certifaction won't call a webhook event if an invited user has accepted the invitation. So the status of the certifaction account inside you application will stay on <code>INVITED</code> even the user already joined. To solve this problem this package can check against the existing accounts of your certifaction instance and synchronize the status of  the existing accounts. If you want that your application done this job on background, make sure you have set up a  schedule for it. </p> routes/console.php<pre><code>// ...\n\nSchedule::job(\\AmaizingCompany\\CertifactionClient\\Jobs\\ProcessAccountSync::class)-&gt;everyFiveMinutes();\n\n// ...\n</code></pre>"},{"location":"users_accounts/#request-an-identification","title":"Request an Identification","text":"<p>If you want that your users able to sign documents they require a higher signature level like QES, they have to prove  their identity to Certifaction. You can request an account identification directly from the Account model.</p> <pre><code>use AmaizingCompany\\CertifactionClient\\Contracts\\Account;\nuse AmaizingCompany\\CertifactionClient\\Enums\\DocumentType;\n\n/**\n * @var Account $account \n */\n$account-&gt;requestIdentification(DocumentType::ID_CARD);\n</code></pre> <p>You see a document type was used to create the identification request. Certifaction accepts two types of documents for  identification. You can call them with the <code>AmaizingCompany\\CertifactionClient\\Enums\\DocumentType</code> Enum.</p> <ul> <li>DocumentType::ID_CARD</li> <li>DocumentType::PASSPORT</li> </ul> <p>The identification request also includes an jurisdiction from <code>AmaizingCompany\\CertifactionClient\\Enums\\Jurisdiction</code>.  By default, the jurisdiction is set to <code>Jurisdiction::eIDAS</code> that is used in the European Union. If the users should  be identified for the Swiss, you should change the default jurisdiction inside the config to <code>Jurisdiction::ZertES</code>.</p> <p>If an identity request was started, a new identity transaction will be created. You can get the current identity  transaction record from the Account model. From there you can get the url where the user can identify himself.</p> <pre><code>$transaction = $account-&gt;getPendingIdentityTransaction();\n\n$transaction-&gt;identification_url;\n</code></pre> <p>Certifaction won't call a webhook event if an identification was finished. So the status of the identification  transaction stays on pending even if the user has identified himself. To solve this problem this package can check  against the existing accounts of your certifaction instance and synchronize the status of the existing accounts.  If you want that your application done this job on background, make sure you have set up a schedule for it. </p> routes/console.php<pre><code>// ...\n\nSchedule::job(\\AmaizingCompany\\CertifactionClient\\Jobs\\ProcessPendingIdentityTransactions::class)-&gt;everyFiveMinutes();\n\n// ...\n</code></pre> <p>The status of an identification request can also be queried directly via the connected model.</p> <pre><code>$account-&gt;requestIdentificationStatusCheck();\n</code></pre>"},{"location":"users_accounts/#request-a-deletion","title":"Request a deletion","text":"<p>To delete an account, a request can be started directly from the account model. If the request is successful, the  corresponding record is also deleted in the background.</p> <pre><code>use AmaizingCompany\\CertifactionClient\\Contracts\\Account;\n\n/**\n * @var Account $account\n */\n$account-&gt;requestDeletion();\n</code></pre>"}]}